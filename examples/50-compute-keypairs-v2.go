// Copyright (c) 2014 Hewlett-Packard Development Company, L.P.
//
//    Licensed under the Apache License, Version 2.0 (the "License"); you may
//    not use this file except in compliance with the License. You may obtain
//    a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
//    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
//    License for the specific language governing permissions and limitations
//    under the License.

package main

import (
	"fmt"
	"git.openstack.org/stackforge/golang-client.git/compute/v2"
	"git.openstack.org/stackforge/golang-client.git/identity/v2"
	"net/http"
	"time"
)

// Image examples.
func main() {
	config := getConfig()

	// Authenticate with a username, password, tenant id.
	auth, err := identity.AuthUserNameTenantName(config.Host,
		config.Username,
		config.Password,
		config.ProjectName)
	if err != nil {
		panicString := fmt.Sprint("There was an error authenticating:", err)
		panic(panicString)
	}
	if !auth.Access.Token.Expires.After(time.Now()) {
		panic("There was an error. The auth token has an invalid expiration.")
	}

	// Find the endpoint for the compute service.
	url := ""
	for _, svc := range auth.Access.ServiceCatalog {
		if svc.Type == "compute" {
			for _, ep := range svc.Endpoints {
				if ep.VersionId == "2" {
					url = ep.PublicURL
					break
				}
			}
		}
	}

	if url == "" {
		panic("v2 compute service url not found during authentication")
	}

	computeService := compute.Service{TokenID: auth.Access.Token.Id, Client: *http.DefaultClient, URL: url}

	createdKeypair, err := computeService.CreateKeyPair("testkeyPairName", "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgQDx8nkQv/zgGgB4rMYmIf+6A4l6Rr+o/6lHBQdW5aYd44bd8JttDCE/F/pNRr0lRE+PiqSPO8nDPHw0010JeMH9gYgnnFlyY3/OcJ02RhIPyyxYpv9FhY+2YiUkpwFOcLImyrxEsYXpD/0d3ac30bNH6Sw9JD9UZHYcpSxsIbECHw== Generated by Nova")
	if err != nil {
		panicString := fmt.Sprint("Cannot create keypair:", err)
		panic(panicString)
	}

	queriedKeyPair, _ := computeService.KeyPair(createdKeypair.Name)
	if err != nil {
		panicString := fmt.Sprint("Cannot requery keypair:", err)
		panic(panicString)
	}

	keyPairs, err := computeService.KeyPairs()
	if err != nil {
		panicString := fmt.Sprint("Cannot access keypairs:", err)
		panic(panicString)
	}

	foundKeyPair := false
	for _, keyPairFound := range keyPairs {
		if queriedKeyPair.Name == keyPairFound.Name {
			foundKeyPair = true
			break
		}
	}

	if !foundKeyPair {
		panic("Cannot find keypair that was created.")
	}

	err = computeService.DeleteKeyPair(queriedKeyPair.Name)
	if err != nil {
		panicString := fmt.Sprint("Cannot delete keypair:", err)
		panic(panicString)
	}
}
